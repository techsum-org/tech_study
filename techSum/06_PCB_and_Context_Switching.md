## 1. `exec`, `fork` 에 따라 PCB 할당의 차이

### fork

`fork` 는 호출 시, 운영체제는 부모 프로세스의 PCB를 복제하여 자식 프로세스의 PCB를 생성함. 복제된 PCB는 자식 프로세스가 부모 프로세스와 독립적으로 실행될 수 있도록 필요한 정보를 담음.

- 부모 프로세스와 자식 프로세스는 동일한 코드 와 데이터를 공유하지만, 각자의 독립적인 PCB를 가짐.

### exec

`exec` 은 현재 프로세스의 메모리 공간에 새로운 프로그램을 로드하여 실행하는 시스템 호출임. 이때 운영체제는 실행 중이던 프로세스의 PCB를 그대로 유지하며, 이미지(코드, 데이터, 스택 등)만 교체됨.

- 쉽게 말해 문맥 교환이 발생하지 않음.

## 2. 문맥 교환 중 오버헤드를 줄이는 방법

1. 멀티스레딩: 멀티스레딩을 사용하여 여러 스레드를 하나의 프로세스 내에서 실행하는 경우, 스레드 간의 문맥교환이 프로세스 간의 문맥교환이 필요한 것보다 더 빠를 수 있음.
    - 스레드 간의 공유하는 자원이 많다면, 동기화 문제 고려
2. 프로세스 간 통신 기법: 프로세스 간에 통신이 필요한 경우, 공유 메모리, 파이프, 소켓 등 통신 기법을 사용하여 문맥교환이 발생하지 않도록 할 수 있음.
3. 이벤트 기반 프로그래밍: 이벤트 기반 프로그래밍 모델을 사용하면, 블로킹되지 않고 이벤트를 기다리는 동안 다른 작업을 처리할 수 있음.
4. 스케줄링 알고리즘 최적화: 스케줄링 알고리즘을 최적화하여 문맥교환의 빈도를 줄일 수 있음.
    - 예를 들어, 우선순위 기반 스케줄링 알고리즘을 사용하여 우선순위가 높은 프로세스를 먼저 실행하도록 할 수 있음.
5. 비동기 입출력: 비동기 입출력을 사용하여 입출력 작업이 완료될 때까지 기다리지 않고 다른 작업을 수행할 수 있음.
    - 이를 통해 입출력 작업이 끝날 때까지 블로킹되지 않고 문맥교환이 발생하지 않음.

## 3. **PCB와 Context Switching** 요약

### **PCB(Process Control Block)**

- PCB는 특정 프로세스에 대한 정보를 담고 있는 자료구조
- PCB는 프로세스의 식별자, 상태, 프로그램 카운터, CPU 레지스터, CPU 스케줄링 정보, 메모리 관리 정보, 계정 정보, I/O 상태 정보 등을 포함
- PCB는 프로세스의 생성 시에 할당되고, 프로세스가 완료되면 제거
- PCB는 운영체제가 프로세스를 관리하고 제어하는 데 사용

### **윈도우 운영체제의 PCB**

- 윈도우 운영체제에서는 PCB 대신 EPROCESS(Extended Process) 구조체를 사용
- EPROCESS는 PCB와 비슷한 역할을 하지만 더 상세하고 다양한 정보를 포함
- EPROCESS는 프로세스의 고유 식별자, 실행 파일 이름, 현재 상태, 스레드 목록, 가상 주소 공간 정보, 핸들 정보, 자원 할당 정보, 보안 토큰 등을 포함

### **맥 운영체제에서의 PCB**

- 맥 운영체제에서는 기존의 PCB를 사용

### **리눅스 운영체제에서의 PCB**

- 리눅스 운영체제에서는 PCB 대신 Task Control Block(TCB) 또는 task_struct라는 용어를 사용
- TCB는 프로세스 및 스레드의 정보를 저장하고 관리하는 역할
- TCB는 프로세스의 고유 식별자, 현재 상태, 프로그램 카운터, CPU 레지스터, 스케줄링 정보, 메모리 관리 정보, 계정 정보, I/O 상태 정보 등을 포함

### **문맥 교환(Context Switching)**

- 문맥 교환은 현재 실행 중인 프로세스의 상태를 PCB에 저장하고 다음 실행할 프로세스의 정보를 PCB에서 불러오는 과정
- CPU는 한 번에 하나의 프로세스만 실행할 수 있으므로, 여러 개의 프로세스를 동시에 실행하는 것처럼 보이기 위해 문맥 교환이 필요
- 문맥 교환은 프로세스 간의 전환을 가능하게 하며, 프로세스의 상태를 보존하고 다음 프로세스를 실행하는 데 사용