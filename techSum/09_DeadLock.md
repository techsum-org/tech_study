## 주제 : Dead Lock


* Race Condition이란 무엇인가요?
  * 답변 : 공유 자원에 대해 여러 프로세스가 동시에 접근을 시도할 때, 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태를 의미합니다.

<br>
<br>

* Critical Section이란 무엇인가요
  * 답변 : 프로세스간 공유 자원 접근 하는데 있어 문제가 발생하지 않도록 한번에 하나의 프로세스만 접근 할 수 있도록 보장 해주어야 하는 영역을 말합니다.

    >예를 들어 두사람이 동시에 입금하는 공통 계좌와 같이 한 사람만 접근할 수 있도록 보장해 주어야 계좌 금액의 일관성을 지킬 수 있습니다. 이때의 공통 계좌를 Critical Section(임계영역)이라 할 수 있습니다.


<br>
<br>

* 프로세스 동기화란 무엇인가요?
  * 답변 : 협력하는 프로세스 사이에서 실행 순서 규칙을 정하여 공유 자원의 일관성을 보장하는 것으로 프로세스들이 서로 동작을 맞추고 정보를 공유하는 것을 의미합니다.

    >예를 들어 기차의 하나의 좌석은 하나만 존재하기 때문에 두사람이 함께 예약을 하지 못하도록 한 사람이 예매에 과정에 들어갔다면 다른이는 이 좌석 예매 과정에 들어갈 수 없도록 하는 것 또한 동기화로 볼 수 있습니다.

<br>
<br>

* 동기화의 도구에는 무엇이 있나요?
  * 답변 : 동기화의 도구에는
    * 임계 구역에 진입하는 프로세스는 Lock을 획득하고 임계구역을 빠져나올때, Lock을 방출함 으로서 동시 접근이 되지 않도록 하는 방법으로 ⇒ <U>락(Lock)</U>
    * 제어되는 섹션에 하나의 스레드만 허용하기 때문에 해당 섹션 접근하기 위해 다른 스레드를 막는 상호배재 기법인 ⇒ <U>뮤텍스(Mutex)</U> 
    * 공유자원 접근에 있어 최대 허용치 만큼 접근을 요청하고 카운트를 이용해 카운트가 0이 되면 대기하도록 하여 상호배제를 달성하는 기법인 ⇒ <U>세마포어(semaphore)</U> 
    * 동시성을 제어하기 위해 하드웨어를 이용하여 동기화 명령어인 <U>Test & Set</U>을 이용한 방법

    이 존재합니다.

    
    

<br>
<br>

* 프로세스 동기화로 생길 수 있는 문제점은 무엇이 있나요?
  * 답변 : 프로세스 동기화로 인해 생길 수 있는 문제점으로


      * 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태인  ⇒ <U>교착 상태(Dead Lock)</U> 
      
      <br>

      * 특정 프로세스의 우선 순위가 낮아서 원하는 자원을 계속 할당받지 못하는 상태인  ⇒ <U>기아 상태(Starvation)</U> 
        
        <br>

      * 공유 자원에 대한 허가를 기다리는 동안 낮은 우선순위의 프로세스와 스케쥴링 순서가 뒤바뀌는 상태인 ⇒ <U>우선순위 역전</U> 
      

    ... 등이 존재합니다.

<br>
<br>

* DeadLock 이란 무엇인가요?
  * 답변 : 교락상태(Dead Lock)이란 두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하는 상태로 무한히 다음 자원을 기다리게 되는 상태를 말합니다.


    >주로 멀티 프로그래밍 환경에서 한정된 자원을 얻기 위해 서로 경쟁하는 상황 발생하게 됩니다.

    >이때 한 프로세스가 자원을 요청했을 때, 동시에 그 자원을 사용할 수 없는 상황이 발생 된다면 프로세스는 대기 상태로 들어가게 되고

    >대기 상태로 들어간 프로세스들이 실행 상태로 변경될 수 없을 때 '교착 상태' 발생하게 됩니다.

<br>
<br>

* Dead Lock은 언제 발생하나요?
  * 답변 : Dead Lock은 4가지 조건이 모두 성립되면 발생하게 됩니다 4가지 조건에는

    - 자원은 한번에 한 프로세스만 사용할 수 있다는 <U>상호 배제(Mutual exclusion)조건</U>
    
    <br>
    
    - 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재한다는 <U>점유 대기(Hold and wait) 조건</U>

    <br>

    - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없다는 <U>비선점(No preemption)조건</U>

    <br>

    - 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 한다는 <U>순환 대기(Circular wait)조건</U>

    <br>

    >4가지 모두 성립해야 데드락 발생하게 되며 하나로도 성립하지 않는다면 Dead Lock 문제가 해결이 가능합니다.


<br>
<br>

* Dead Lock의 처리는 어떻게 하나요?
  * 답변 : Dead Lock의 처리에는 예방,회피,회복,처리가 존재하며

    * Deadlock Prevention은 자원을 할당할 때 Deadlock의 4가지 필요조건 중 어느 하나가 만족되지 않도록 하는 방식입니다 

    >하지만 이렇게 미리 Deadlock을 방지하는 방식은 효율성과 처리량을 감소시키고, Starvation이 발생할 수 있습니다.
    
    <br>

    * Deadlock Avoidance는 Deadlock이 발생할 가능성이 있는 경우엔 아예 자원을 할당하지 않는 방식으로 가장 단순하고 일반적인 모델은 프로세스들이 필요로 하는 각 자원별 최대 사용량을 미리 선언하도록 하는 방법입니다.

      * Resource Allocation Graph Algorithm (자원 할당 그래프 알고리즘) 
      * Banker's Algorithm
      
      <br> 

      >와 같은 탐지 알고리즘을 통해 발생 가능성을 확인 하여 자원을 아예 할당 하지 않는 방식으로 이루어 집니다.


    <br>

    * Deadloc 회복은 프로세스를 종료시켜 Dead Lock을 회복합니다.

       종료 판단 기준으로

        <br>

      - 프로세스의 중요도

      - 프로세스가 얼마나 오래 실행됐는가

      - 얼마나 많은 자원을 사용했는가

      - 프로세스가 작업을 마치기 위해 얼마나 많은 자원이 필요한가

      - 프로세스가 종료되기 위해 얼마나 많은 자원이 필요한가

        가 있으며 기준에 따라 Deadlock에 빠진 모든 프로세스를 종료하거나, Deadlock이 해결될 때까지 한 번에 한 프로세스씩 종료시킬 수 있습니다.


<br>
