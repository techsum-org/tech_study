# 주제 : Dead Lock

## 목차
- 주제 : DeadLock
  - [Race Condition이란?]()
  - [Critical Section이란?]()
  - [process synchronization]()
  - [Dead Lock이란?]()
  - [Dead Lock 예방]()
  - [Dead Lock 회피]()
  - [Dead Lock 회복]()
  - [Dead Lock 무시]()
  - [Dead Lock 정리]()

<br>

---

## Race Condition

<img width="675" alt="경합조건" src="">

**경합(경쟁) 상태 (Race Condition)**

정의 : 공유 자원에 대해 여러 프로세스가 동시에 접근을 시도할 때, 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태를 말한다.
    
>  <U>두 가지 이상의 명령어 혹은 프로세스가 실행되는 순서를 명확하게 정해주지 않아</U>서 어떤 <U>명령어가 먼저 실행될 지 몰라</U> 그 <U>**결과를 알 수 없게 되는 것**</U>이라는 뜻이다.



>이로 인해 동시에 접근할 때 자료의 **`일관성`** 을 해치는 결과가 나타날 수 있다.

<br>

**경합 조건이 일어나는 조건!**

- 두 개 이상의 프로그램 혹은 스레드가 공통된 자원에 접근하여 읽기/쓰기 와 같은 작업이 일어날때!

    <br>


    <details>
    <summary>실생활 예시</summary>

    **사람 A,B가 동일한 계좌에 동시에 금액을 입금하는경우**

    - 작업 처리 단위
        1. 계좌 금액을 읽음
        2. 읽은 값에 입금 금액을 더함
        3. 계좌에 반영시킴

    - 문제 상황 순서
        
        <계좌에 10만원이 존재>
        
        1. A가 계좌 금액을 읽음(10만원)
        2. B가 계좌 금액을 읽음(10만원)
        3. A가 10만원에 5만원을 더함
        4. B가 10만원에 3만원을 더함
        5. A가 계좌에 반영 시킴.
        6. B가 계좌에 반영 시킴.
        
        ⇒ 최종 계좌에 반영된 금액 → 13만원
        

    **경쟁 상태 발생 예시)**

    - 커널 작업을 수행 중에 인터럽트가 발생 하여 동일 데이터를 조작할때
    - 프로세스가 system call을 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환이 발생하여 동일 데이터를 조작할 때,
    - 멀티 프로세서에서 공유 메모리 내의 동일한 커널 데이터에 여러 프로세스가 접근할 때

    </details>


<br>



---


## Critical Section

### 공유 자원

정의 : 여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일

<br>

`경합조건` 에서의 공유자원이 하나의 계좌인것 처럼

⇒ 컴퓨터 분야에서 공유자원은 어떤게 될 수 있을까?

<br>

예시)

- 스레드간 공유 메모리
    
    ⇒ 한 프로세스내 여러 스레드는 메모리의 코드, 데이터 힙 영역을 공유하여 사용한다.
    
    <br>

    ⇒ ( 참고, 스레드는 독립적인 작업의 흐름이기에 각자의 스택과 PC(Program Counter)는 따로 할당된다.)

    <br>    

- 프린터 공유
    
    ⇒ 여러 사용자들이 하나의 프린터를 공유하여 사용한다.
    
    ⇒ 여러 사용자들의 문서가 프린터에서 뒤섞인다면 제대로 작동하지 않는다.
    
    <br>
⇒ 공유 자원을 사용함에 있어 늘 공유 자원 접근시에 문제가 뒤따른다.

<br>
<br>


### Critical Section(임계 영역)

정의 : 프로세스간 공유 자원 접근 하는데 있어 문제가 발생하지 않도록 한번에 하나의 프로세스만 접근 할 수 있도록 보장 해주어야 하는 영역을 말한다. 

<br>

**임계영역을 해결하기 위한 3가지 조건**

⇒ 임계 영역을 문제를 해결 하기 위해 3가지 조건을 충족하여야 한다.

- 상호 배재 ( Mutual Exclusion )
    - 하나의 프로세스가 임계영역에 접근 하였을 경우 다른 프로세스는 접근할 수 없어야 한다.
- 진행 ( Progress )
    - 현재 이용하지 않는 임계영역에 접근하는 프로세스가 여러개라면 어떤 프로세스가 들어가야 할지 결정해주어야 한다.
- 한정 대기 ( Bounded Waiting )
    - 다른 프로세스의 기아(Starvation)현상을 방지하기 위해 임계영역에 들어간 프로세스는 다음 임계영역에 들어갈 때 제한을 두어야 한다.


<br>

**임계 영역 동시 접근 해결 방법**

- Lock
- Semaphore
- monitor
    
    .. 등이 존재한다.

---

<br>

## process synchronization (프로세스 동기화)

<br>

### process synchronization (프로세스 동기화)

정의 : 협력하는 프로세스 사이에서 실행 순서 규칙을 정하여 공유 자원의 일관성을 보장하는 것

⇒ 다르게 말하면 동기화는 프로세스들이 서로 동작을 맞추고 정보를 공유하는 것을 의미

<br>

**동기화와 관련한 고전적인 문제**

✓ **은행 계좌 문제 (Back Account Problem)**

- 부모는 은행 계좌에 입금을 한다. 자식은 은행 계좌에서 출금한다.
- 입금과 출금 과정이 별도로 이루어져야 한다.
- **Critical Section** : 은행 계좌

<br>

✓ **식사하는 철학자 문제 (Dining Philosopher Problem)**

- 원형 테이블에 철학자들이 앉아있고 철학자의 수만큼 젓가락이 철학자 사이에 하나씩 놓여있다.
- 철학자들이 식사를 하기 위해서는 양쪽에 하나씩 놓여있는 젓가락을 둘 다 들어서 사용해야 한다.
- 어떤 철학자가 젓가락을 사용 중이라면, 다른 어떤 철학자는 식사를 할 수 없다.
- **Critical Section** : 젓가락


<br>

**동기화의 도구**

- 락(lock)
    
    동시에 공유 자원 접근 하는것을 막기 위해 임계 구역에 진입하는 프로세스는 Lock을 획득하고 임계구역을 빠져나올때, Lock을 방출함 으로서
    
    ⇒ 동시 접근 되지 않도록 적용하는 방법
    
    <br>

    <details>
    <summary>참고) Spin Lock</summary>

    만약 다른 스레드가 lock을 소유하고 있다면 그 lock이 반환될 때까지 계속 확인하며 기다리는 것으로 
    
    >"조금만 기다리면 바로 쓸 수 있는데 굳이 Context Switching으로 부하를 줄 필요가 있는가?"
    
     라는 컨셉으로 개발된 것으로 Critical Section에 진입이 불가능할때 컨텍스트 스위칭을 하지 않고 잠시 루프를 돌면서 재시도 하는 것을 말한다. (busy wating 이라고도 불림 ) 

    </details>
    
    
    
    
    <br>

- 소프트웨어적 동기화
    - **뮤텍스** : 제어되는 섹션에 하나의 스레드만 허용하기 때문에 해당 섹션 접근하기 위해 다른 스레드를 막는 상호배재 기법
        - 피터슨의 알고리즘 (Peterson's Algorithm)
        - 데커의 알고리즘 (Dekker's Algorithm) 
        - 제과점 알고리즘 (Bakery Algorithm)
        
        <br>

    - 세마포어 : 세마포어란 공유 자원에 대해 접속을 제어하기 위해  최대 허용치 만큼 접근을 요청하고 카운트를 이용해 카운트가 0이 되면 대기하도록 하여 상호배제를 달성하는 기법
        
        
    <br>

- 하드웨어적 동기화
    
    ⇒ 하드웨어적 동기화 방법은 하드웨어의 도움을 받아 두 명령어를 동시해 실행시키는 방식으로 진행된다.
    
    - Test And Set
        - 명령어는 동시성을 제어하기 위한 동기화 명령어 중 하나로서, 하드웨어의 도움을 받아 수행된다.
        - 한정 대기 조건을 만족하지 못하는 단점


<br>
<br>


**동기화로 인해 발생하는 문제**

* 교착상태 (Dead Lock)
  * 두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태
  
  <br>

* Starvation (기아) - Infinite Blocking (무한 대기)
  * 특정 프로세스의 우선 순위가 낮아서 원하는 자원을 계속 할당받지 못하는 상태, 기아 상태
    
    <br>

* Priority Inversion (우선순위 역전)
  * 공유 자원에 대한 허가를 기다리는 동안 낮은 우선순위의 프로세스와 스케쥴링 순서가 뒤바뀌는 상태 
  

... 등이 존재한다.

  <br>

---

##  Dead Lock이란?


<img width="865" alt="DeadLock" src="">

**Dead Lock**
* 정의 : 두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하는 상태로 무한히 다음 자원을 기다리게 되는 상태를 말한다.


(주로 발생하는 경우)

멀티 프로그래밍 환경에서 한정된 자원을 얻기 위해 서로 경쟁하는 상황 발생

한 프로세스가 자원을 요청했을 때, 동시에 그 자원을 사용할 수 없는 상황이 발생할 수 있음. 이때 프로세스는 대기 상태로 들어감

대기 상태로 들어간 프로세스들이 실행 상태로 변경될 수 없을 때 '교착 상태' 발생

<br>
<br>

**데드락(DeadLock) 발생 조건**

- 상호 배제(Mutual exclusion)
  - 자원은 한번에 한 프로세스만 사용할 수 있음

<br>

- 점유 대기(Hold and wait)
  - 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함

<br>

- 비선점(No preemption)
  - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음

<br>

- 순환 대기(Circular wait)
  - 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함

<br>

4가지 모두 성립해야 데드락 발생

(하나라도 성립하지 않으면 데드락 문제 해결 가능)

<br>

---
## Dead Lock 예방

**Deadlock Prevention**
 

미리 예방하는 방식인 Deadlock Prevention은 자원을 할당할 때 Deadlock의 4가지 필요조건 중 어느 하나가 만족되지 않도록 하는 방식이다. 

*  Mutual Exclusion 
   *  Critical Section Problem을 해결하기 위해서는 이 조건은 반드시 만족해야 하므로 공유자원이 존재한다면 이 조건은 만족시킬 수밖에 없다. 

<br>

* Hold and Wait
  * 프로세스가 자원을 요청할 때 다른 어떤 자원도 가지고 있지 않도록 해야 한다.
  * 따라서 프로세스를 시작할 때 모든 필요한 자원을 할당받게 하거나, 자원이 필요한 경우 보유하고 있던 자원을 모두 반납하고 다시 요청하는 방식을 이용할 수 있다. 

<br>

* No preemption

  * 프로세스가 어떤 자원을 기다려야 하는 경우 보유하고 있던 자원이 선점된다. 그리고 모든 필요한 자원을 얻을 수 있을 때 그 프로세스는 다시 시작된다. 

<br>

* Circular wait

  * 자원의 타입에 따라 프로세스마다 할당 순서를 정하여 정해진 순서대로만 자원을 할당한다. 

<br>

하지만 이렇게 미리 Deadlock을 방지하는 방식은 효율성과 처리량을 감소시키고, Starvation이 발생할 수 있다. 

<br>



<br>

---
## Dead Lock 회피

**Deadlock Avoidance**
 
Deadlock Avoidance는 Deadlock이 발생할 가능성이 있는 경우엔 아예 자원을 할당하지 않는 방식이다. 가장 단순하고 일반적인 모델은 프로세스들이 필요로 하는 각 자원별 최대 사용량을 미리 선언하도록 하는 방법이다. 

<br> 

**Safe Sequence & Safe State**

* Safe Sequence : 프로세스의 sequence <P1, P2, ..., Pn>이 있을 때, Pi의 자원 요청이 '가용 자원 + 모든 Pj (j < i)의 보유 자원'에 의해 충족되는 경우 sequence를 safe 하다고 말한다. 

* Safe state : 시스템 내의 프로세스들에 대한 Safe Sequence가 존재하는 상태

 

>만약 시스템이 Safe state에 있으면 Deadlock이 발생하지 않는다.

>하지만 Unsafe state에 있으면 Deadlock이 발생할 수 있다. 따라서, Deadlock Avoidance는 시스템이 Unsafe state에 들어가지 않는 것을 보장하는 것이다. 

<br>

**Dead Lock회피 알고리즘**
 

두 경우의 Avoidance 알고리즘이 있는데, 
* 각 자원 타입마다 하나의 인스턴스가 존재하는 경우 자원 할당 그래프 알고리즘을 사용하고, 
* 여러 인스턴스가 존재하는 경우 Banker's 알고리즘을 사용한다. 

<br>

1. Resource Allocation Graph Algorithm (자원 할당 그래프 알고리즘) 

    <img width="675" alt="자원할당그래프" src="">
    
    <br>

    점선으로 표시된 간선(Claim edge)은 프로세스가 자원을 미래에 요청할 수 있음을 의미한다.

    그리고 해당 자원을 요청하는 경우 실선(Request edge)으로 바뀌게 된다.

    자원을 할당받으면 방향이 반대인 간선(Assignment edge)이 된다.

    만약 자원을 다 쓰고 반납하게 되면 다시 Claim edge로 바뀐다. 

 

Deadlock를 피하는 방법은, Request edge가 Assignment edge로 변경될 때 점선을 포함하여 사이클이 생기지 않는 경우에만 요청된 자원을 할당한다.

 
<br>
<br>
 

2. Banker's Algorithm


    여러 인스턴스가 존재하는 경우엔 사이클만으로 판단할 수는 없다. 

    Banker's Algorithm은 dijkstra가 고안한 알고리즘이며, 이는 프로세스가 자원을 요청할 때마다 수행된다. 
    
    <br>

    <가정>

    - 모든 프로세스는 자원의 최대 사용량을 미리 명시한다.

    - 프로세스가 요청 자원을 모두 할당받은 경우 유한 시간 안에 자원들을 다시 반납한다. 
    
    <br>

    기본적인 개념은, 자원을 요청할 때 safe 상태를 유지하는 경우에만 할당한다. 즉, 총 요청 자원의 수가 남은 자원의 수보다 적은 프로세스만 선택하여 수행한다. 만약 그런 프로세스가 없다면 unsafe 상태인 것이다. 

    할당받은 프로세스가 종료되면 모든 자원을 반납하고, 모든 프로세스가 종료될 때까지 이 과정을 반복한다. 

<br>

---

## Dead Lock 회복

Deadlock을 해결하기 위해 어떤 프로세스를 종료시켜 Dead Lock을 회복한다. 

<br>

여기에는 몇 가지 판단 기준이 있다.

<br>

- 프로세스의 중요도

- 프로세스가 얼마나 오래 실행됐는가

- 얼마나 많은 자원을 사용했는가

- 프로세스가 작업을 마치기 위해 얼마나 많은 자원이 필요한가

- 프로세스가 종료되기 위해 얼마나 많은 자원이 필요한가



프로세스를 종료시킬 땐 Deadlock에 빠진 모든 프로세스를 종료하거나, Deadlock이 해결될 때까지 한 번에 한 프로세스씩 종료시킬 수 있다.


<br>

---

## Dead Lock 무시

Deadlock이 일어나지 않는다고 생각하고 아무런 조치도 취하지 않는 방식이다. 

<br>

그 이유는, Deadlock이 매우 드물게 발생하기 때문에 Deadlock에 대한 조치 자체가 더 큰 오버헤드일 수 있기 때문이다. 따라서 만약 시스템에 Deadlock이 발생한 경우, 시스템이 비정상적으로 작동하는 것을 사람이 느낀 후 직접 프로세스를 죽이는 등의 방법으로 대처한다. 

<br>

이 방식은 UNIX, Windows 등 대부분의 범용 운영체제가 채택하는 방식이다. 

 

<br>

---

## DeadLock 정리

