# 주제 : IPC(nter Process Communication)

## 목차
- 주제 : IPC(Inter Process Communication)
  - [IPC란]()
  - [IPC가 필요한 이유]()
  - [IPC의 종류]()
  - [IPC 정리]()

<br>

---

## IPC(Inter Process Communication)?
<img width="675" alt="스크린샷 2023-05-26 오전 5 10 26" src="">

* 정의 : IPC(Inter Process Communication)란 프로세스간의 통신을 위한 메커니즘을 의미한다.  

<br>

<img width="675" alt="IPC" src="">

위 그림처럼 우리가 사용하는 프로세스들은 모두 유저공간(user-space, user-mode)에서 개별로 OS로부터 할당받은 독립된 공간에서 운행중에 있다

그렇기 때문에 프로세스는 독립된 공간에서 운행하다보니 서로간에 통신이 어렵다는 문제가 존재한다.

이를 해결하고자 커널 영역(kernel-space, kernel-mode)에서 IPC(Inter-Process Communication)라는 프로세스들 간에 통신을 제공하고 있으며 프로세스들은 커널이 제공하는 IPC 기술을 통해 프로세스간에 통신을 할 수 있다.

<br>

<br>

<img width="675" alt="IPC 모델" src="">

 IPC는 다음과 같이 두 가지 모델로 나뉜다.
* Shared Memory
* Message Passing 

<br>

---


## IPC(Inter Process Communication)가 필요한 이유

**IPC(Inter Process Communication)는 왜 필요할까?**




*  정보 공유(Information Sharing):
   * 여러 사용자가 동일한 정보에 엑세스 할 필요가 있을 수 있다.

* 가속화(Computation Speed-up):
  * 특정 작업(task)을 여러 개의 서브 작업(sub-task)로 쪼개어 프로세스의 병렬성을 키움으로써 처리 속도를 높일 수 있다.

    이 때 메인 작업과 서브 작업은 서로 통신의 필요성이 생긴다.

* 모듈화(Modularity):
  * 특정한 시스템 기능을 별도의 프로세스(스레드)로 구분하여 모듈화된 시스템을 구성할 수 있다. 이 때 모듈간의 통신이 필요하다

* 편의성(Convenience):
  * 다수의 사용자가 동시에 여러가지 작업을 수행할 수 있다.

<br>

---

## IPC(Inter Process Communication)의 종류

**Message Passing System**
Message Passing 방식은 공유되는 주소 공간 없이 프로세스간 통신할 수 있다. 이 때 message passing 방식은 send(전송), receive(수신) 연산을 통해 통신하게 된다. 만약 프로세스 P와 Q가 통신하고 싶다면, 둘은 communication link를 둘 사이에 만들어야 한다.

PIPE (파이프)

파이프는 두 개의 프로세스를 연결하고 하나의 프로세스는 데이터를 쓰기만 하고, 다른 프로세스는 데이터를 읽기만 한다
부모 자식 간에 단방향 통신으로 자주 사용한다
한쪽 방향으로만 통신이 가능한 PIPE의 특징 때문에 Half-Duplex(반이중) 통신 이라고도 불린다
PIPE는 반이중 통신이기에 하나의 통신선로는 읽기/쓰기 중 하나만 가능하므로 만약 읽기/쓰기, 즉 송/수신을 모두 하기 원한다면 두 개의 파이프를 만들어야 가능하다
read()와 write()가 기본적으로 block mode로 작동되기에 프로세스가 read 대기중이라면 read가 끝나기전에는 write를 할 수 없다
장점

PIPE는 간단하게 사용할 수 있다는 장점이 있다. 한쪽 프로세스는 단지 읽기만하고 다른 프로세스는 단지 쓰기만 하는 단순한 데이터 흐름에 적합
단점

Full-Duplex(전이중) 통신 방식으로 활용하려면 PIPE를 두개 만들어야 하는데, 구현이 꽤나 복잡해 질 수 있다 (굳이 전이중을 활용해야한다면 PIPE말고 다른 방법을 찾는게 효율적일 수 있다)
buffer가 상대적으로 작기때문에 overflow 될 확률이 높다 (read처리를 빨리빨리 해줘야한다)
부모 자식 관계의 프로세스들 사이에서 가능
 

 

 

Named PIPE (익명 파이프)

Linux는 모든 것을 파일(fd)로 통하고 있다는 개념을 기억하고 보자
Named PIPE는 통신을 할 프로세스가 명확히 알 수 있는 경우 사용
보통 PIPE는 부모자식간에 사용하고 Named PIPE는 전혀 모르는 상태의 프로세스들 사이에서 통신할 경우 사용
Named PIPE는 부모프로세스와 무관하게 전혀 다른 모든 프로세스들 사이에서 통신이 가능한데, 이유는 프로세스간에 통신을 위해 이름이 있는 파일을 매개체로 사용하기 때문
mkfifo를 통해 Named PIPE를 생성하는데, mkfifo가 성공하면 이름이 명명된 파일이 생성되고 이를 활용해서 프로세스 간에 통신이 이루어짐
장점

기본 PIPE와 비슷
단점

읽기/쓰기가 동시에 이루어지지 않음, 단방향 통신, read-only or write-only
기본 PIPE와 비슷
PIPE 와 Named PIPE

공통점
먼저 입력된 데이터가 먼저 전달되는 흐름을 가진다는 측면에서 동일한 데이터 흐름 메커니즘을 가진다

차이점
Named PIPE는 사용할 PIPE를 명명할 수 있다는 점
PIPE는 사용할 PIPE를 명명할 수 없다
(그렇기 때문에 PIPE는 익명 PIPE라 부른다)


추가 설명
익명 파이프(PIPE)는 데이터 통신을 할 프로세스가 명확하게 알 수 있을 때 사용
송신할 프로세스는 수신할 프로세스를 알고, 수신할 프로세스는 송신할 프로세스를 아는 경우
가장 대표적인 예가 부모프로세스와 자식프로세스간에 데이터 통신을 하고자 할 때 부모 프로세스와 자식 프로세스는 서로를 명확히 알고 있으므로 굳이 파이프에 이름을 줄 필요가 없을 것이다

반면, 자식과 부모 관계가 아닌 전혀 모르는 프로세스들 사이에서 pipe를 이용해서 통신을 해야하는 경우는 우리가 생판 모르는 사람과 대화를 하려면 이름을 알아야 하듯 pipe에 이름을 주어져야 한다, 그것이 Named PIPE를 만든 이유이다

Message Queue (메시지 큐)

FIFO(First-In First-Out, 선입선출) 자료구조를 가지는 통신설비로 커널에서 관리
입출력 방식으로보면 위에 Named PIPE와 동일하다 할 수 있다
차이점이라면, Named PIPE는 데이터의 흐름이라면 Message Queue는 메모리 공간이라는 점
어디서나 물건을 꺼낼 수 있는 컨테이너 벨트와 같다 보면 된다
Message Queue에 쓸 데이터에 번호를 붙힘으로써 다수의 프로세스가 동ㅇ시에 데이터를 쉽게 다룰 수 있다
장점

비동기 방식이기에 방대한 처리량이 있다면 큐에 넣은 후 나중에 처리 할 수 있다
다수의 프로세스들이 큐에 메시지를 보낼 수 있고 다수의 프로세스들이 큐로부터 메시지를 꺼낼 수 있다
분산처리 및 경쟁처리 방식에 사용할 수 있다
(비동기, 비동조, 탄력성, 과잉, 확장성이 있는데 이건 다른 포스트 참조해도 충분할 거 같다)
단점

메시지가 정말 잘 전달되었는지 알 수 없다
큐에 데이터를 넣고 나오는 과정에서 오버헤드가 발생 할 수 있다
데이터가 많이 쌓일수록 추가적인 메모리 자원이 필요하다


<br>


**Shared Memory**
Shared Memory 방식은 말 그대로 프로세스들이 공유하는 메모리를 이용해 통신하는 것이다. 이때 공유할 item을 생성하는 생산자(producer) 프로세스와 생성한 item을 소비하는 소비자(consumer) 프로세스가 나뉘게 된다. 즉, 생산자가 공유 메모리(buffer)에 item을 생산하고 저장하면, 소비자가 이를 읽고 소비하게 된다. 

 

이때 중요한 것은 동기화(synchronize)가 필요하다는 것


Shared Memory
데이터 공유 방법에는 크게 2가지가 있는데,
통신을 이용해서 데이터를 주고 받는 방법 (ex. PIPE, Named PIPE, Message Queue, ...)
데이터를 공유, 즉 함께 사용하는 것 (ex. Shared Memory, ...)
즉, 공유메모리가 데이터 자체를 공유하도록 지원하는 설비이다
Shared Memory(공유 메모리)는 프로세스간 메모리 영역을 공유해서 사용할 수 있도록 허용
프로세스가 공유 메모리 할당을 커널에 요청하면 커널은 해당 프로세스에 메모리 공간을 할당해 주게되고, 이후 어떤 프로세스건 해당 메모리영역에 접근 할 수 있다
장점
공유 메모리는 중개자 없이 곧바로 메모리에 접근할 수 있기 때문에 모든 IPC중에서 가장 빠르게 작동한다
(다시말해, 커널메모리영역에서 관리하기에 빠르게 접근 가능)
단점
메시지 전달 방식이 아니기에 데이터를 읽어야하는 시점을 알 수 없다



Semaphore (세마포어
PIPE, Named PIPE, Message Queue와 같은 다른 IPC 설비들이 대부분 프로세스간 메시지 전송을 목적으로 하는데 반해,
Semaphore는 프로세스 간 데이터를 동기화하고 보호하는데 그 목적이 있다
프로세스간 메시지 전송을 하거나 공유메모리를 통해 데이터를 공유하게 될 경우 발생하는 문제가 공유된 자원에 다수의 프로세스가 동시에 접근하면 안되며 단지 하나의 프로세스만 접근가능하게 해주는것이 세마포어(Semaphore) 이다
즉, 운영 체계 또는 프로그램 작성 내에서 공유 자원에 대한 접속을 제어하기 위해 사용되는 신호
한 프로세스가 사용하고 있는 동안에 세마포어를 세워서 다른 프로세스를 대기시키고 사용이 끝나면 해제시키는 방법으로 사용

장점

많은 Thread들은 크리티컬 섹션을 허락받아야 한다. 즉, 크리티컬 섹션에서 충돌이 나지 않는다
단점

많은 Thread들은 block을 당한다. 즉, CPU가 가만히 waiting하는 시간 낭비가 발생할 수 있다




Socket (소켓, UDS = Unix Domain Socket)

같은 도메인 내에서 연결 될 수 있고 프로세스들 사이의 통신을 가능하게 한다
서버단에서는 bind, listen, accept 진행해 소켓 연결을 위한 준비를 한다
클라이언트 단에서는 connect을 통해 서버에 요청하고 연결이 수립 된 후에서는 socket에 send 함으로써 데이터를 주고 받는다.
연결이 끝나면 반드시 close()로 clear 한다
즉, 네트워크를 통해 프로세스간에 통신을 진행한다
장점

서버/클라이언트 환경을 구축하는데 용이하다
Internet Socket인 경우 데이터 유실이 발생할 수 있지만, Unix Domain소켓은 PIPE와 같은 형태로 이루어지고 같은 시스템에서 교환이 일어나므로 패킷이 유실되거나, 순서가 바뀌는 등 문제가 발생하지 않을거라 장담 할 수 있다
범용적인 IPC로써 양방향 통신이 가능하다
패킷 단위로 주고 받음으로 직관적으로 이해하기 쉬운 코드를 만들 수 있다
단점

Internet UDP와는 달리 경로를 지정할 수 없다 (다중의 클라이언트를 받아들이는 서버의 경우 문제가 될 수 있다)




<br>

---

## IPC 정리

* IPC란 무엇인가요?
  * 답변 : 

<br>
