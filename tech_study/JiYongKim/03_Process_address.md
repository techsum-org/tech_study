# 주제 : Process_address

## 목차
- 주제 : Process & Thread
  - [Memory 구조](#memory-구조)
  - [Process와 Thread 구조](#process와-thread-구조)
  - [Process와 Thread의 생성 비용](#process와-thread의-생성-비용)
  - [Thread의 Stack과 Register를 독립적으로 생성하는 이유](#thread의-stack과-register를-독립적으로-할당-하는-이유)
  - [StackOverflow](#stack-overflow)
  - [Process_address 정리 ](#process_address-정리)

<br>

---

## Memory 구조

<메모리구조이미지>

- Text(code) 영역: 텍스트 영역은 쉽게 말하면 코드를 실행하기 위해 저장되어있는 영역이다.

    흔히 코드 영역이라고도 하는데, 프로그램을 실행시키기 위해 구성되는 것들이 저장되는 영역이다. 제어문, 함수, 상수들이 이 영역에 저장이 된다.
    
<br>
    
  - Data 영역: 전역 변수가 이곳에 저장된다. 그 외에 프로그램이 실행될 때 생성되고 프로그램이 종료되면 시스템에 반환되며 정적변수, 배열, 구조체 등이 저장되는 곳이다. 
    >이 때 초기화 된 데이터에는 data 영역에 저장되고, 초기화되지 않은 데이터는 BSS(Block Stated Symbol)영역에 저장된다.

<br>
 

  - Heap 영역: '사용자에 의해 관리되는 영역'으로
    
    흔히 동적으로 할당 할 변수들이 여기에 저장
    
    Java나 C++에서 new 연산자로 생성하는 경우 또는 class, 참조 변수들도 힙 영역에 차지하게 된다. 

<br>

  - Stack 영역: 지역변수와 인자, 그리고 함수의 리턴 주소를 가진다. 

    함수를 호출 시에 생성이 되고, 함수가 끝나면 반환이 된다. 
    Stack 사이즈는 각 프로세스마다 할당되지만, 프로세스가 메모리에 로드될 때 Stack 사이즈가 고정되어 있어 런타임시에 Stack 사이즈를 바꿀 수 없다.

<br>


---

## Process와 Thread 구조

<Process와 Thread 구조 이미지>

프로세스란 운영체제로부터 자원을 할당받아 프로그램이 메모리 상으로 올라갔을 때의 상태를 의미한다.

그렇기에 위의 메모리 구조에서
으용프로그램의 각각의 데이터들이 메모리에 적재되어 있는 상태를 의미하게 됩니다.



<br>


---

## Process와 Thread의 생성 비용

<Process와 Thread 구조 이미지>

* 프로세스 생성시 ( fork() → exec()방식 )
  - OS 로부터 할당받아야 하는 용량
      - Code
      - Data
      - Bss
      - 동적 영역
          - heap
          - stack
    
    ⇒ 위의 메모리의 자원을 OS를 통해 모두 할당 받아 새로운 프로세스를 생성한다.

* Thread 생성시
  - OS 로부터 할당받아야 하는 용량
    - 각 스레드에 필요한 스택영역 생성
    - 프로세스의 Code, Data, Heap 영역은 공유하게 된다.

<br>

>프로세스 생성시 메모리 영역별 자원을 새로 할당해줘야 하는 반면,

>스레드 생성시, 각 스레드에 필요한 Stack영역만 생성하고 프로세스의 Code, Data, Heap영역을 공유한다

>⇒ 이러한 근거를 통해 **프로세스 생성보다  스레드 생성비용이 더 적게 든다는 결과**가 도출된다.


<br>


---



## Thread의 Stack과 Register를 독립적으로 할당 하는 이유

<Process와 Thread 구조 이미지>

- Thread의 Stack을 독립적으로 할당하는 이유
  - 스택은 <U>함수 호출 시 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간</U>이다.

    >따라서 스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고, 이는 독립적인 실행 흐름이 추가되는 것이다.

    결과적으로 <U>실행 흐름의 추가를 위한 최소 조건이 독립된 스택을 제공</U>하는 것이다

     만약, 스택영역을 공유하게 된다면 각 스레드별 함수 호출의 복귀 주소가 꼬여버릴 수 있다.

<br>

- PC Register를 스레드마다 독립적으로 할당하는 이유
  - PC Register값은 스레드가 명령어의 어디까지 수행하였는지를 나타나게 된다.
  - 스레드는 CPU를 할당받았다가 **스케줄러**에 의해 다시 선점당한다. 그렇기 때문에 명령어가 연속적으로 수행되지 못하고, 어느 부분까지 수행했는지 기억할 필요가 있다.
   
    ⇒ 따라서 PC 레지스터를 독립적으로 할당한다.


<br>

---

## Stack Overflow

Stack Overflow는 **(원인)스택에 할당된 크기보다 더 큰 데이터를 넣어 메모리 주소를 넘치게 사용 되어**  **벗어난 데이터가 다른 데이터 까지 덮어씌어 예기치 못한 오류를 일으키는 것**을 의미한다.

- 대표적인 예 재귀함수
    - 함수를 호출할 때 함수의 파라미터, 리턴 값, 복귀 주소 등을 스택에 저장한다.
    - 재귀 함수를 사용하면 호출한 함수가 종료되지 않은 채 새로운 함수를 호출하므로 스택에 메모리가 계속적으로 저장되게 되므로 스택 메모리에 더 이상 가용 메모리가 없을 경우에 스택 오버 플로우가 발생하게 된다.

<br>

---

## Process_address 정리

* 메모리에는 어떠한 영역이 있고 영역별 무슨 데이터가 저장되는지 설명해주세요
  * 답변 : 메모리에는 
    * 프로그램을 실행시키기에 필요한 코드 즉 제어문 함수 상수들이 저장되는 <U>코드영역</U>
    * 전역 변수가 저장되는 영역으로 초기화된 데이터는 Data영역에 초기화 되지 않은 데이터는 BSS영역에 저장되는 <U>Data영역</U>
    * 사용자에 의해 동적으로 할당되는 <U>Heap영역</U>
    * 지역 변수와 인자, 그리고 함수의 리턴주소를 저장하는 <U>Stack영역</U>
    
    으로 구성됩니다.

<br>

* Process가 Thread보다 생성비용이 더 큰 이유를 설명해주세요
  * 답변 : 프로세스 생성시에 OS로부터 할당 받아야하는 메모리 공간으로는
      - Code
      - Data
      - Bss
      - 동적 영역
          - heap
          - stack
    
    영역들을 할당받아야 하는 반면 스레드
    
    스레드 생성시, 각 스레드에 필요한 Stack영역만 생성하고 프로세스의 Code, Data, Heap영역을 공유하기 때문에 
    
    스레드 생성 비용이 더 적게 들게 됩니다.

    
<br>

* Thread의 Stack영역과 PC Register 값을 따로 할당하는 이유를 설명해주세요
  * 답변 : 

    * 스택영역을 따로 할당하는 이유는 스레드는 함수호출과 같은 독립적인 실행 흐름을 가져야하기 때문에 스레드별 스택영역을 할당하여 독립적 흐름에 문제가 생기지 않도록 하는것 입니다.
    * PC Register 값을 따로 할당하는 이유는 스레드는 스케쥴링에 의해 CPU를 선점하여 실행하는 방식을 사용하며 CPU 자원을 다른 스레드에게 선점 당했을 경우 자신이 다음에 진행할 정보를 저장해야 하기 때문에 각각의 PC Register 값을 할당 하는것 입니다.
  

<br>

* Stack Overflow가 무엇인지와 예시에 대해 설명해주세요
  * 답변 : Stack Overflow란 메모리 구조에서 스택에 할당된 크기보다 더 큰 데이터를 넣어 메모리 주소를 넘치게 되어 벗어난 데이터가 다른 데이터 까지 덮어씌어 예기치 못한 오류를 일으키는 것을 의미합니다.

    Stack Overflow의 예시로는 무분별한 재귀함수 사용이 있습니다.

    재귀함수는 함수를 호출할 때 함수의 파라미터, 리턴 값, 복귀 주소 등을 스택에 저장하게 됩니다.
  
    재귀 함수를 사용하면 호출한 함수가 종료되지 않은 채 새로운 함수를 호출하므로 스택에 메모리가 계속적으로 저장되게 되므로 스택 메모리에 더 이상 가용 메모리가 없을 경우에 스택 오버 플로우가 발생하게 됩니다.

<br>