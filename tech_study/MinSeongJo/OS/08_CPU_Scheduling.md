# CPU Scheduling 

---
## Table of Contents
* [CPU 스케줄링에 대해](#about the CPU Scheduling)
* [CPU 스케줄링의 종류](#cpu-스케줄링의-종류)
* [FCFS에 대하여](#first-come-first-served-fcfs)
* [SJF에 대하여](#sortest-job-first-sjf)
* [우선순위 큐](#priority)
* [라운드로빈](#round-robinrr)
* [다중큐](#multi-level-queue-mlq)
* [다중 피드백 큐](#mulit-level-feedback-queue-mlfq)

---
## <font color="yellow">프로세스 상태</font>
<img src="https://velog.velcdn.com/images%2Fwhwkd11010%2Fpost%2Fec40d7df-d665-41da-89c8-b975652c1688%2F%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%83%81%ED%83%9C.png">

* **new** : 프로세스가 생성 중인 상태 (커널공간에 PCB가 만들어진 상태)
* **Ready** : 프로세스가 CPU를 얻으려고 대기중인 상태 (CPU를 제외한 필요한 자원들을 모두 얻은 상태)
* **Running** : 프로세스가 CPU를 할당 받아 명령어를 수행중인 상태
* **Blocked** : 프로세스가 CPU를 할당 받아도 당장 실행할 수 없는 상태 (현재 프로세스가 I/O 작업 등을 처리 중인 상태를 의미)
* **terminated** : 프로세스의 실행 종료 (프로세스 실행이 완료되고 할당된 CPU를 반납, Kernel 내의 PCB는 남아있음)
* **suspended** : 프로세스의 중지 상태 (메모리를 강제로 뺏긴 상태로 특정한 이유로 프로세스 수행이 정지된 상태를 의미한다. 외부에서 다시 재개시키지 않는 이상 활성화될 수 없음.)

---

### 스케줄링의 단계

#### 고수준 스케줄링 (작업 스케줄링)

- 가장 큰 틀에서 이루어지는 CPU 스케줄링을 고수준 스케줄링 또는 장기 스케줄링, 작업 스케줄링이라고 함
- 시스템 내의 전체 작업 수를 조절하는 것을 말한다.
  - 작업은 운영체제에서 다루는 일의 가장 큰 단위로, 1개 또는 여러 개의 프로세스로 이루어진다
- 고수준 스케줄링 단게에서는 어떤 작업을 시스템이 받아들일지 또는 거부할지를 결정함.


#### 저수준 스케줄링

- 고수준 스케줄링과는 반대로 가장 작은 단위의 스케줄링을 저수준 스케줄링이라고 한다.
- 저수준 스케줄링은 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정함

#### 중간 수준 스케줄링

- 고수준 스케줄링과 저수준 스케줄링 사이에 일어나는 스케줄링
- 중간 수준 스케줄링은 중지와 활성화로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하를 막는다.
  - 즉, 일부 프로세스를 중지 상태로 옮김으로써 나머지 프로세스가 원만하게 작동하도록 지원한다. (보류 상태)

### 스케줄링의 목적

원래의 목적은 모든 프로세스가 공평하게 작업하도록 하는 것이다. 특정 프로세스에 편중되지 않게 골고루 자원을 배분하기 위해 공평성을 유지하면서도 안정적으로 작동 해야한다.

- **공평성** : 모든 프로세스가 <U>자원을 공평하게 배정</U>받아야 하며, 자원 배정 과정에서 특정 프로세스가 배제되어서는 안 된다.
- **효율성** : <U>시스템 자원이 유휴 시간 없이 사용</U>되도록 스케줄링을 하고, 유휴 자원을 사용하려는 프로세스에는 우선권을 주어야한다.
- **안정성** : 우선순위를 사용하여 중요 프로세스가 먼저 작동하도록 배정함으로써 <U>시스템 자원을 점유하거나 파괴하려는 프로세스로부터 자원을 보호</U>해야 한다.
- **확장성** : <U>프로세스가 증가해도 시스템이 안정적으로 작동</U>하도록 조치해야 한다. 또한 시스템 자원이 늘어나는 경우 이 혜택이 시스템에 반영되게 해야 한다.
- **반응 시간 보장** : 응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야 한다.
- **무한 연기 방지** : 특정 프로세스의 <U>작업이 무한히 연기되어서는 안 된다</U>.

### 선점형 스케줄링과 비선점형 스케줄링
- **선점형 스케줄링** : 어떤 프로세스가 CPU를 할당받아 <U>실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는</U> 스케줄링이다.
- **비선점형 스케줄링** : 어떤 프로세스가 CPU를 점유하면 <U>다른 프로세스가 이를 빼앗을 수 없는 스케줄링</U> 방식이다.

| 구분   |선점형|비선점형|
|:-----|:--|:--|
| 작업방식 |실행 상태에 있는 작업을 중단시키고 새로운 작업을 실행할 수 있다.|실행 상태에 있는 작업이 완료될 때까지 다른 작업이 불가능하다.|
| 장점   |프로세스가 CPU를 독점할 수 없어 대화형이나 시분할 시스템에 적합하다.|CPU 스케줄러의 작업량이 적고 문맥 교환의 오버헤드가 적다.|
| 단점   |문맥교환의 오버헤드가 많다.|기다리는 프로세스가 많아 처리율이 떨어진다.|
| 사용   |시분할 방식 스케줄러에 사용된다.|일괄 작업 방식 스케줄러에 사용된다.|
| 중요도  |높다.|낮다.|


### CPU 스케줄링의 종류

**1) FCFS**

가장 간단한 스케줄링 기법으로, 먼저 대기 큐에 들어온 작업에게 CPU를 먼저 할당하는 비선점 스케줄링 방식

**2) SJF**

SJF는 비선점 스케줄링 기법으로, 처리하여야 할 작업시간이 가장 적은 프로세스에 CPU를 할당하는 기법
평균 대기 시간이 최소인 최적의 알고리즘이지만, 각 프로세스의 CPU 요구 시간을 미리 알기 어렵다는 단점이 있음

**3) Priority**

각 작업마다 우선순위가 주어지며, 우선순위가 제일 높은 작업에 먼저 CPU가 할당되는 방법
우선순위가 낮은 작업은 Indefinite Blocking 이나 Starvation에 빠질 수 있고, 이에 대한 해결책으로 체류시간에 따라 우선 순위가 높아지는 Aging 기법을 사용할 수 있음

**4) Round-Robin**

FIFO 스케줄링 기법을 Preemptive 기법으로 구현한 스케줄링 방법으로 프로세스는 FIFO 형태로 대기 큐에 적재되지만, 주어진 시간 할당량(Time Slice) 안에 작업을 마쳐야 하며, 할당량을 다 소비하고도 작업이 끝나지 않은 프로세스는 다시 대기 큐의 맨 뒤로 되돌아감 (선점 스케줄링)
사용자에게 적합한 응답시간을 제공해주는 대화식 시분할 시스템에 적합하다.

**5) SRT**

SJF 스케줄링 기법의 선점 구현 기법으로, 새로 도착한 프로세스를 비롯하여 대기 큐에 남아 있는 프로세스의 작업이 완료되기까지의 남아있는 실행 시간 추정치가 가장 적은 프로세스에 먼저 CPU를 할당하는 방법

**6) HRN 스케줄링**

Brinch Hansen이 SJF 스케줄링 기법의 약점인 긴 작업과 짧은 작업의 지나친 불평등을 보완한 스케줄링 기법
우선순위는 $$우선순위 = 대기 시간 + 서비스 시간 /over 서비스시간$$로 결정된다.
서비스 시간이 분모에 있어 짧은 작업의 우선순위가 높아지고, 대기 시간을 분자에 둠으로써 긴 작업도 대기 시간이 큰 경우 우선순위가 높아지게 됨.

**7) Multi-Level Queue**

작업 또는 우선순위 별 별도의 Ready Queue를 가짐
최초 배정된 Queue를 벗어나지 못하며 각각 Queue는 자신만의 스케줄링 기법 사용

   **시스템 변화 적응 어려움** 

Queue 사이에는 우선순위 기반 스케줄링 사용
- 장점 : **중요한 것들은 빠르게 처리함**
- 단점 : 여러 개의 Queue를 관리 **(overhead 큼)**, 우선순위가 낮다면 starvation **무한대기** 현상 발생 가능

**8) Multi-Level Feedback Queue**

다양한 특성의 작업이 혼합된 경우 매우 유용한 스케줄링 방법으로, 새로운 프로세스는 그 특성에 따라 각각 대기 큐에 들어오게 되며, 그 실행 형태에 따라 다른 대기 큐로 이동함
예를 들어 연산 위주의 프로세스들은 처음에 RR 방식의 대기 큐에서 주어진 시간 할당량이 만료되면 다음 단계의 큐에 배치되고, 실행 시간이 길수록 점점 낮은 우선 순위를 지니게 되어 마지막 가장 낮은 우선 순위의 큐에 도달하면 작업이 끝날 때 까지 RR방식으로 스케줄링 된다.

### First Come First Served의 동작방식 (FCFS)
#### <font color="pink">FCFS (First Come First Served)</font> 스케줄링의 동작 방식
* 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식
* 한 번 실행되면 <font color="pink">그 프로세스가 끝나야만 다음 프로세스를 실행할 수 있음</font>
  $$\rarr$$ 비선점형 특징
* 큐가 하나라 모든 프로세스는 우선순위가 동일

#### FCFS 스케줄링의 성능
<img src="https://velog.velcdn.com/images/minseong1459/post/ea13bf4a-50eb-44e5-abde-c8e750cb415c/image.png">

#### FCFS 스케줄링의 평가
* 처리 시간이 <font color="pink">긴 프로세스가 CPU를 차지하면 다른 프로세스들은 하염없이 기다려 시스템의 효율성이 떨어짐</font>
* 특히 현재 작업 중인 프로세스가 입출력 작업을 요청하는 경우 CPU가 작업하지 않고 쉬는 시간이 많아져 작업 효율이 떨어짐


### Shortest Job First (SJF)

#### SJF (shortest Job First) 스케줄링의 동작 방식
* 준비 큐에 있는 프로세스 중에서 실행시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식
* 최단 작업 우선 스케줄링이라고도 함
* 콘보이 효과를 완화하여 시스템의 효율성을 높임


#### SJF 스케줄링의 성능
<img src="https://velog.velcdn.com/images/minseong1459/post/4b2dd603-3200-4a39-b16c-b8a1cef65a8d/image.png">

#### SJF 스케줄링의 평가
* 운영체제가 프로세스의 종료 시간을 정확하게 예측하기 어려움
* 작업 시간이 길다는 이유만으로 계속 뒤로 밀려 공평성이 현저히 떨어짐. 이를 <font color="pink">아사 (starvation) 현상</font> 이라 부름

#### 에이징 (aging, 나이 먹기)
* 아사 현상의 완화 방법
* 프로세스가 양보할 수 있는 상한선을 정하는 방식
* 프로세스가 자신의 순서를 양보할 때마다 나이를 한 살씩 먹어 최대 몇 살까지 양보하도록 규정하는 것

### HRN

#### HRN (highest Response Ratio Next) 스케줄링의 동작 방식

* SJF 스케줄링에서 발생할 수 있는 **아사 현상을 해결하기 위해 만들어진 비선점형 알고리즘**
* 최고 응답률 우선 스케줄링이라고도 함
* 서비스를 받기 위해 기다린 시간과 CPU 사용 시간을 고려하여 스케줄링을 하는 방식
* 프로세스의 우선순위를 결정하는 기준

 $$우선순위 = 대기시간+CPU사용시간\over CPU사용시간$$

#### HRN 스케줄링의 성능

<img src="https://velog.velcdn.com/images/minseong1459/post/526805e5-aa87-4ef5-8b08-7205b8d367f1/image.png">

#### HRN 스케줄링의 평가
* 실행 시간이 짧은 프로세스의 우선순위를 높게 설정하면서도 대기 시간을 고려하여 아사 현상을 완화
* 대기 시간이 긴 프로세스의 우선순위를 높임으로서 CPU를 할당받을 확률을 높임
* 여전히 공평성이 위배되어 많이 사용되지 않음

### Round-Robin(RR)

#### 라운드 로빈 (Round Robin) 스케줄링의 동작 방식
* 한 프로세스가 할당받은 시간 (타임 슬라이스) 동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식
* 선점형 알고리즘 중 가장 단순하고 대표적인 방식
* 프로세스들이 작업을 완료할 때까지 계속 순환하면서 실행

#### 라운드 로빈 스케줄링의 성능
<img src="https://velog.velcdn.com/images/minseong1459/post/0bdd32e7-45e5-444a-8442-fd248bf408d3/image.png">

#### 라운드 로빈 스케줄링의 평가
* 라운드 로빈 스케줄링과 FCFS 스케줄링의 평균 대기 시간이 같다면 라운드 로빈 스케줄링이 더 비효율적임
* 라운드 로빈 스케줄링 같은 선점형 방식에는 문맥 교환 시간이 추가되기 때문

### SRT

#### SRT (Shortest Remaining Time) 스케줄링의 동작 방식
$\rarr$ 선점형
* 기본적으로 라운드 로빈 스케줄링을 사용하지만, CPU를 할당받을 프로세스를 선택할 때 남아 있는 작업 시간이 가장 적은 프로세스를 선택
#### SRT 스케줄링의 성능
<img src="https://velog.velcdn.com/images/minseong1459/post/a2a6a927-4ab4-4b5f-8f58-2066de7525d6/image.png">


#### SRT 스케줄링의 평가
* 현재 실행 중인 프로세스와 큐에 있는 프로세스의 남은 <font color="pink">시간을 주기적으로 계산</font>하고, <font color="pink">남은 시간이 더 적은 프로세스와 문맥 교환을 해야 하므로</font> SJF 스케줄링에는 없는 작업이 추가됨.
* 운영체제가 <font color="pink">프로세스의 종료 시간을 예측하기 어렵고</font> 아사 현상이 일어나기 때문에 잘 사용하지 않음

### priority

#### 우선순위 (priority) 스케줄링의 동작방식
* 프로세스의 중요도에 따른 우선순위를 반영한 스케줄링 알고리즘
  <img src="https://velog.velcdn.com/images/minseong1459/post/b83d6342-5492-471e-8baa-c19833f6b041/image.png">

#### 우선순위 적용
* 우선순위는 <font color="pink">비선점형 방식</font>과 <font color="pink">선점형 방식</font>에 <font color="pink">모두 적용</font>할 수 있음

   - (비선점형 방식) **SJF 스케줄링** : 작업 시간이 짧은 프로세스에 높은 우선순위를 부여
   - (비선점형 방식) **HRN 스케줄링** : 작업 시간이 짧거나 대기 시간이 긴 프로세스에 높은 우선순위를 부여
   - (선점형 방식) **SRT 스케줄링** : 남은 시간이 짧은 프로세스에 높은 우선순위를 부여

#### 고정 우선순위 알고리즘 $\rarr$ 다단계(MLQ)
* 한 번 우선순위를 부여받으면 종료될 때 까지 우선순위가 고정
* 단순하게 구현할 수 있지만 시시각각 변하는 시스템의 상황을 반영하지 못해 효율성이 떨어짐
#### 변동 우선순위 알고리즘 $\rarr$ HRN
* 일정 시간마다 우선순위가 변하여 일정 시간마다 우선순위를 새로 계산하고 이를 반영
* 복잡하지만 시스템의 상황을 반영하여 효율적인 운영 가능

#### 우선순위 스케줄링의 평가
* 준비 큐에 있는 프로세스의 순서를 무시하고 <font color="pink">우선순위가 높은 프로세스에 먼저 CPU를 할당</font>하므로 <font color="pink">공평성을 위배하고 아사 현상을 일으킴</font>
* 준비 큐에 있는 프로세스의 순서를 무시하고 프로세스의 우선순위를 매번 바꿔야 하기 때문에 <font color="pink">**오버헤드**</font>가 발생하여 시스템의 효율성을 떨어뜨림.


### Multi-Level Queue (MLQ)

### 다단계 큐 (MLQ; Multi-Level Queue) 스케줄링의 동작 방식
* <font color="pink">우선순위에 따라 준비 큐를 여러 개 사용하는 방식</font>
* 프로세스는 운영체제로부터 부여받은 우선순위에 따라 해당 우선순위의 큐에 삽입
* <font color="pink">**우선순위는 고정형 우선순위를 사용**</font>
* 상단의 큐에 있는 모든 프로세스의 작업이 끝나야 다음 우선순위 큐의 작업이 시작됨.

### Mulit-Level Feedback Queue (MLFQ)

#### 다단계 피드백 큐 (MLFQ; Multi-Level Feedback Queue) 스케줄링의 동작 방식
* 프로세스가 <font color="pink"> CPU를 한 번씩 할당받아 실행될 때마다 프로세스 우선순위를 낮추므로 </font> 다단계 큐에서 우선순위가 낮은 프로세스의 실행이 연기되는 문제 완화
* 우선순위가 낮아지더라도 커널 프로세스가 일반 프로세스 큐에 삽입되지 않음
* 우선순위에 따라 타임 슬라이스의 크기가 다름
* 우선순위가 낮아질수록 CPU를 얻을 확률이 적어짐. 따라서 한번 CPU를 잡을 대 많이 작업하라고 낮은 우선순위의 타임 슬라이스를 크게 함
* 마지막 큐에 있는 (우선순위가 가장 낮은) 프로세스는 무한대의 타임 슬라이스 얻음
* 마지막 큐는 들어온 순서대로 작업을 마치는 FCFS 스케줄링 방식으로 동작




### 좋은 스케줄링의 판단 기준

1. **CPU 이용률**
    - 모든 CPU 스케줄링 알고리즘의 목적은 CPU를 최대한 바쁘게 유지하는 것
2. **처리량**
    - CPU에서 수행한 작업의 척도. 시간당 실행되고 완료되는 프로세스의 수
3. **반환시간**
    - 프로세스 요청시간에서 완료시간 까지의 경과시간
4. **대기시간**
    - 프로세스가 레디큐에 들어가기 위해 대기한 시간
5. **응답시간**
    - 프로세스의 요청에서 첫번째 응답이 생성될 때까지 걸리는 시간


---
<br>
### 각 스케줄링 알고리즘의 trade-off

1. FCFS
    - 장점 : 구현이 간단하며, 공평한 프로세스 실행 순서를 제공
    - 단점 : 평균 대기 시간이 길어지는 경우가 있음. 긴 프로세스가 먼저 도착하면 뒤에 있는 짧은 프로세스들은 오랜 시간 동안 기다려야 할 수 있음.
2. SJF
    - 장점 : 평균 대기 시간을 최소화하여 효율적인 스케줄링 제공
    - 단점 : 실행 시간을 예측하기 어려운 경우가 있음. 긴 작업이 계속해서 도착하면 짧은 작업들이 오랜 시간동안 기다려야 할 수 있음.
3. Priority Scheduling
    - 장점 : 우선순위에 따라 중요한 작업을 먼저 처리할 수 있음
    - 단점 : 우선순위 설정에 주의가 필요하며, 낮은 우선순위의 프로세스가 긴 시간 동안 대기 할 수 있음. 또한, 우선순위가 높은 프로세스가 계속 실행되면 다른 프로세스들이 무시될 수 있음(우선순위 불균형 문제)
4. Round Robin (RR)
    - 장점 : 모든 프로세스에 CPU 시간을 공평하게 할당함, 응답 시간을 일정하게 유지할 수 있음
    - 단점 : 프로세스의 시간 할당량이 크면 대기 시간이 증가함. 또한, 프로세스의 동작이 짧은 경우에도 시간 할당량이 크면 효율성이 떨어질 수 있음
5. SRT
    - 장점 : 평균 대기 시간을 최소화하고, 짧은 작업에 대한 응답 시간을 향상시킴
    - 단점 : 실행 시간을 예측하기 어려운 경우가 있음. 짧은 작업이 게속해서 도착하면 긴 작업들이 오랜 시간 동안 대기해야 할 수 있음
6. HRN
    - 장점 : 응답 시간을 최대화함. 긴 작업이 오래 기다린 경우에 대한 보상을 제공함
    - 단점 : 응답 비율을 계산하는 과정이 복잡할 수 있음. 또한, 긴 작업이 계속해서 도착하면 짧은 작업들이 오랜시간 동안 대기해야 할 수 있음
7. MLQ
    - 장점 : 서로 다른 우선순위의 프로세스에 다른 스케줄링 알고리즘을 적용하여 다양한 작업 요구 사항에 대응할 수 있음.
    - 단점 : 각 큐 간의 우선순위 설정이나 프로세스 이동에 따른 오버헤드가 발생할 수 있음.
8. MLFQ
    - 장점 : 프로세스의 동적인 행동에 따라 큐를 조정하여 유연하게 스케줄링할 수 있음. 짧은 작업은 빠른 응답 시간을 받을 수 있음
    - 단점 : 큐의 설정이나 동적인 큐 이동에 대한 알고리즘을 설계하는 것이 어려울 수 있음. 또한, 우선순위 역전 문제가 발생할 수 있음.


