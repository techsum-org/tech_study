## PCB와 Context Switching
---
### PCB(Process Control Block)

- 특정 프로세스에 대한 정보를 담고 있는 자료구조
    - 운영체제는 PCB에 담긴 프로세스 정보를 이용하여 프로세스를 관리하고 제어함. 프로세스가 생성될 때마다 고유의 PCB가 생성되어 메인 메모리에 유지되고, 프로세스가 완료되면 제거됨. PCB는 프로세스의 중요한 정보를 포함하고 있으므로 일반 사용자는 접근하지 못하는 보호된 메모리 영역에 존재함.
- 상세 구조

| 항목 | 설명 |
| --- | --- |
| Process id | 프로세스의 고유 식별자 |
| Process state | 프로세스의 상태(실행, 대기, 준비 등) |
| Program counter | 현재 실행 중인 명령어의 주소를 가리키는 레지스터 |
| CPU register | CPU에서 사용한 레지스터의 값을 저장하는 PCB의 필드 |
| CPU scheduling information | 프로세스의 우선순위, 최종 실행 시간, 스케줄링 큐를 가리키는 포인터 등 |
| Memory management information | 레지스터, 페이지 테이블, 세그먼트 테이블의 base, limit값에 대한 정보 |
| Accounting information | CPU 사용 시간, 실제 사용된 시간, 시간 제한 등 |
| I/O status information | 프로세스에 할당된 I/O 기기에 대한 정보 |
- 진행 과정: 프로세스 생성 → PCB 할당 → PCB 초기화 → 프로세스 정보 입력
    1. 프로세스 생성: 새로운 프로세스가 생성되면 운영체제에 의해 PCB를 생성함. 프로세스 생성은 일반적으로 프로세스 관리 시스템 호출에 의해 수행.
    2. PCB 할당: PCB를 위한 메모리 공간이 할당. 운영체제는 적절한 크기의 메모리를 할당하여 PCB를 저장할 수 있는 공간을 마련.
    3. PCB 초기화: 할당된 PCB는 초기 상태로 설정. 이 단계에서는 PCB 내부의 필드들을 초기 값으로 설정하게 됨. 예를 들어, 프로세스 식별자, 상태, 우선순위 등의 필드를 초기화.
    4. 프로세스 정보 입력: 프로세스의 생성과 동시에 PCB에 관련 정보가 입력. 프로세스의 식별자, 프로그램 카운터(PC), 레지스터 값, 할당된 자원, 스케줄링 정보 등이 PCB에 저장.
    
    PCB는 운영체제가 프로세스 관리를 위해 사용하는 중요한 데이터 구조로서, 각 프로세스의 정보를 보관하고 필요에 따라 업데이트할 수 있도록 함. 프로세스 생성과정에서 PCB는 초기화되며, 프로세스의 상태 변화나 자원 할당 등에 따라 PCB의 내용이 업데이트되는 것임.
    
- PCB가 필요한 이유: CPU는 프로세스의 상태에 따라 교체 작업이 이루어짐. 이때, 교체되는 프로세스의 상태 값을 PCB에 저장했다가 다시 수행할 때 사용함.
- 관리 방식: 연결 리스트 방식으로 관리됨. 따라서 삽입, 삭제가 용이하며 프로세스 생성 시 해당 PCB가 생성되고, 프로세스가 완료되면 제거됨.

### 윈도우 운영체제의 PCB

- 윈도우 운영체제의 PCB: 윈도우 운영체제에서는 프로세스 관리를 위해 PCB(Process Control Block) 대신에 EPROCESS(Extended Process) 구조체를 사용함.
    - 상세 구조
        
        
        | 항목 | 설명 |
        | --- | --- |
        | UniqueProcessId | 프로세스를 고유하게 식별하는 식별자 값 |
        | ImageFileName | 프로세스 실행 파일의 이름 |
        | ProcessState | 프로세스의 현재 상태를 나타내는 정보 |
        | ThreadListHead | 프로세스에 속한 스레드 목록을 가리키는 포인터 |
        | Pcb | 스레드 제어 블록(TCB)을 가리키는 포인터 |
        | VadRoot | 가상 주소 공간(Virtual Address Space)에 대한 정보 |
        | Handles | 프로세스가 소유한 핸들 목록을 저장하는 테이블 |
        | QuotaBlock | 프로세스의 자원 할당 정보를 저장하는 블록 |
        | Token | 프로세스의 보안 토큰 정보를 가리키는 포인터 |
        | ParentProcessId | 부모 프로세스의 식별자 값 |
    - 기존 PCB와의 차이점
        1. 데이터 구조: 기존 PCB는 간단한 데이터 구조로서 프로세스의 상태 및 일부 정보를 저장하는 역할을 하지만 윈도우 운영체제의 PCB(EPROCESS)는 더 상세하고 다양한 정보를 포함하는 구조체. 프로세스의 상태, 스레드, 가상 주소 공간, 핸들, 자원 할당 정보, 보안 등 다양한 측면에서의 정보를 포함함.
        2. 확장성: 기존 PCB는 일반적으로 고정된 필드를 가지고 있어 확장이 어렵지만, 윈도우 운영체제의 EPROCESS는 유연한 확장성을 가지고 있어 필요에 따라 새로운 필드나 구조를 추가할 수 있음.
        3. 운영체제 기능 지원: 윈도우 운영체제의 EPROCESS는 운영체제의 다양한 기능을 지원하기 위해 설계됨. 예를 들어 보안 관리, 메모리 관리, 스케줄링 등 다양한 운영체제 기능과의 효율적인 상호작용을 위해 최적화되어 있음. 기존 PCB는 단순히 프로세스 관리에 초점을 맞추고 있음.
        4. 보안: 윈도우 운영체제의 EPROCESS는 보안 관련 정보를 포함하여 프로세스의 보안 토큰, 권한, 권한 검사 등을 관리할 수 있음. 이를 통해 윈도우 운영체제는 보다 강력한 보안 기능을 제공할 수 있음.

### 맥 운영체제에서의 PCB

- 맥 운영체제에서의 PCB: 기존의 PCB를 사용함.

### 리눅스 운영체제에서의 PCB

- 리눅스 운영체제에서의 PCB: 리눅스 운영체제에서는 Task 구조체 또는 Task Control Block(TCB)라는 용어를 사용함. TCB는 프로세스에 대한 정보를 저장하고 프로세스 제어와 관련된 기능을 제공.
    - 상세 구조
    
    | 항목 | 설명 |
    | --- | --- |
    | Process ID | 프로세스의 고유 식별자 |
    | Process State | 프로세스의 현재 상태 |
    | Program Counter | 다음에 실행될 명령어의 주소 |
    | Registers | CPU 레지스터의 상태 정보 |
    | Scheduling Information | 우선순위, 실행 시간 등 스케줄링에 필요한 정보 |
    | Memory Management Information | 가상 주소 공간, 페이지 테이블 등 메모리 정보 |
    | Accounting Information | CPU 사용 시간, 시간 제한 등의 정보 |
    | I/O Status Information | 할당된 I/O 장치와 관련된 정보 |
    | Process-related Information | 부모 프로세스 ID, 자식 프로세스 목록 등 |
    - 기존 PCB와의 차이점
        1. 대상: PCB는 프로세스를 관리하는 데 사용되고, TCB는 스레드를 관리하는 데 사용. PCB는 프로세스의 전반적인 정보를 저장하고 추적하는 데 사용되는 반면, TCB는 스레드의 실행 상태와 관련된 정보를 저장.
        2. 범위: PCB는 프로세스 수준에서 생성되고 사용. 즉, 프로세스 당 하나의 PCB가 할당. TCB는 각 스레드마다 별도의 TCB가 할당되기에 여러 PCB가 할당될 수 있음.
        3. 정보의 종류: PCB는 프로세스의 실행 상태, 자원 할당 정보, 프로세스 관계, 메모리 관리 정보, I/O 상태 등 다양한 정보를 포함. TCB는 스레드의 실행 상태, 레지스터 값, 스케줄링 정보 등 스레드와 관련된 정보를 포함.
        4. 생성 시점: PCB는 프로세스가 생성될 때 생성되고 초기화. TCB는 스레드가 생성될 때 생성되고 초기화.
        5. 관리 단위: PCB는 프로세스 간의 상호작용과 프로세스의 상태 전환을 관리하는 데 사용. TCB는 스레드의 실행, 스케줄링, 상태 전환 등을 관리하는 데 사용.
        6. 구조의 크기: 일반적으로 PCB는 TCB보다 더 많은 정보를 포함하므로 더 큰 크기를 가지기 쉬움.
    - 리눅스 운영체제에서 주의해야할 점
        - 실제로 리눅스 운영체제에서는 PCB라는 개념이 있음. 이는 task_struct인데, 리눅스에서는 TCB(Task Control Block)의 개념을 task_struct 구조체로 표현하고, 이를 사용하여 프로세스와 스레드의 정보를 저장하고 관리함. task_struct 구조체는 리눅스 커널에서 프로세스 및 스레드에 대한 정보를 저장하는 주요 데이터 구조임. 이 구조체는 각 프로세스 및 스레드마다 할당되며, 해당 프로세스 또는 스레드의 상태, 스케줄링 정보, 자원 할당 정보, 메모리 관리 정보, 파일 상태 등 다양한 정보를 담고 있습니다.
            
            따라서 TCB로서의 역할을 수행하며, task_struct 구조체를 사용하여 프로세스와 스레드의 실행 상태와 관련된 정보를 저장하고 관리합니다. 이를 통해 스케줄링, 자원 관리, 동기화 등의 작업을 수행할 수 있습니다.
            
---
### 문맥 교환(Context Switching)

- 현재 진행하고 있는 프로세스의 상태를 PCB에 저장하고 다음 진행할 프로세스의 정보를 PCB에서 읽어 적용하는 과정임.
    - 쉽게 말하면 저장하고 불러오는 과정, 한 프로세스에서 다른 프로세스로 전환되는 과정임.
- 문맥 교환이 필요한 이유: CPU는 한 번에 하나의 프로세스만 수행할 수 있음. 그러나 실제로 CPU는 여러 개 프로세스를 동시 수행하려고 하기에 CPU는 동시 수행처럼 보이기 위해 여러 개의 프로세스를 번갈아가며 수행함. 따라서 CPU가 프로세스를 바꿔가며 실행하기 위해 문맥 교환이 필요해짐.
- 문맥 교환의 과정
    1. 현재 실행 중인 프로세스의 상태 저장: 현재 실행 중인 프로세스의 레지스터 상태, 프로그램 카운터(PC), 스택 포인터 등의 정보를 해당 프로세스의 PCB(Process Control Block)에 저장
    2. 다음 실행할 프로세스의 상태 로드: 다음으로 실행할 프로세스의 PCB에서 저장된 정보를 로드하며, 이로써 CPU는 다음으로 실행할 프로세스의 상태로 전환
    3. 메모리 관리 정보 변경: 문맥 교환으로 인해 메모리 할당이 변경되었을 경우, 해당 정보를 업데이트함. 예를 들어, 페이지 테이블, 세그먼트 테이블 등의 정보를 수정
    4. 스케줄링 및 인터럽트 처리: 문맥 교환은 일반적으로 스케줄러에 의해 수행하며, 스케줄링 알고리즘을 사용하여 다음으로 실행할 프로세스를 선택하고, 해당 프로세스로 제어를 넘김. 또한, 인터럽트가 발생한 경우 해당 인터럽트를 처리할 수 있도록 필요한 작업을 수행
    5. 다음 프로세스 실행: 로드된 상태의 프로세스를 실행. CPU는 새로운 프로세스로 전환되었으며, 해당 프로세스의 명령어를 실행.
    
    위의 과정은 프로세스 간의 전환이 발생하며, 이를 문맥 교환이라고 함. 문맥 교환 과정에서는 프로세스가 실행되기 전까지의 대기 시간과 메모리 비용을 오버헤드라고 함.
    
- 문맥 교환의 발생 시점
    - CPU 스케줄링에 의해 할당된 작업시간이 끝나 timeout이 발생했을 때 발생
    - 프로세스의 작업이 끝났을 때 발생
    - 실행 중이던 프로세스가 입출력 요청을 할 때 발생